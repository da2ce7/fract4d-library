Direct Gaussian Integer {
init:
  int iter = 0

  color accumulator = @startcolor; initialize color accumulator
  color current = rgb(0,0,0); holds current iteration's color

  bool usesolid = true   ; assume a solid color
loop:
  iter = iter + 1        ; iteration counter

}

Direct Decomposition {
; 4-way decomposition using a direct coloring algorithm
; tends to get a bit blurry as you zoom further in
init:
int cq1
int cq2
int cq3
int cq4
loop:
int q = 0
if(real(z) < 0.0) 
	q = 1
endif
if(imag(z) < 0.0) 
	q = q + 2
endif
if q == 0
   cq1 = cq1 + 1
elseif q == 1
   cq2 = cq2 + 1
elseif q == 2
   cq3 = cq3 + 1
else
   cq4 = cq4 + 1
endif
final:
#color = @c1 * (cq1/#numiter) + @c2 * (cq2/#numiter) + @c3 * (cq3/#numiter) + @c4 * (cq4/#numiter)
default:
color param c1
	default = rgb(1.0,0.0,0.0)
endparam
color param c2
	default = rgb(0.0,1.0,0.0)
endparam
color param c3
	default = rgb(0.0,0.0,1.0)
endparam
color param c4
	default = rgb(0.0,0.0,0.0)
endparam
}

Hot And Cold {
; 2 colors - on each orbit, the closer we are to 0, the more hot,
; the closer we are to bailout, the more cold. Compute an average over
; all iterations 

init:
float dist=0.0
int closecalls=0
int farcalls=0
loop:
dist = |z|
if dist < @closedist
   closecalls = closecalls + 1
elseif @bailout - dist < @fardist
   farcalls = farcalls + 1
endif
final:
#color = @hotcolor * (closecalls/#numiter) + @coldcolor * (farcalls/#numiter)
default:
float param fardist
	default = 1.0
endparam
float param closedist
	default = 0.2
endparam
float param bailout
	default = 4.0
endparam
color param hotcolor
	default = rgb(0.97, 0.43, 0.01)
endparam
color param coldcolor
	default = rgb(0.49, 0.79, 0.96)
endparam
}

velocity {
init:
complex oldz = 0.0
float speed = 0.0
loop:
	speed = |#z - oldz|
	oldz = z
final:
	#index = log(speed)
}

final_position {
final:
	#index = real(z) * imag(z) + real(z) + imag(z)
default:
} 


Signs {
; based on when sign changes occur for x or y parts of z
init:
complex lastz = (-1,-1)

int min_iter_x = 0
int max_iter_x = 0
int min_iter_y = 0
int max_iter_y = 0

loop:
if real(z) * real(lastz) < 0 
   max_iter_x = #numiter
endif
if imag(z) * imag(lastz) < 0 
   max_iter_y = #numiter
endif
lastz = z
final: 
if @sign_type == "x iter" 
    #index = max_iter_x/256.0
elseif @sign_type == "y iter"
    #index = max_iter_y/256.0
endif 
default:
param sign_type
	default = 0
	enum = "x iter" "y iter"
endparam
}

angular_velocity {
init:
complex oldz = 0.0
float speed = 0.0
float oldspeed = 0.0
loop:
	oldspeed = speed
	speed = atan2(#z) - atan2(oldz)
	oldz = z
final:
	if speed < 0
	speed = speed + #pi * 2.0
	endif
	if oldspeed < 0
	oldspeed = oldspeed + #pi * 2.0
	endif 
	float factor = @bailout/(|z| + 1.0e-9)	
	#index = #numiter + speed * factor ; + oldspeed * (1.0 - factor)
default:
float param @bailout
	default = 4.0
endparam
}

cumulative_1 {
init:
complex oldz = 0.0
float speed = 0.0
float oldspeed = 0.0
loop:
	oldspeed = speed
	speed = |#z - oldz|
	oldz = z
final:
	float factor = 4.0/|z|
	#index = oldspeed * (1.0 - factor) + factor * speed
default:
float param dampfactor
	default = 0.99
endparam
}

dca {
final:
	#color = rgb(1,1,1)
}

dca2 {
final: 
float ed = @bailout/(|z| + 1.0e-9) 
float index = (#numiter + ed) / 256.0
#color = gradient(index)
default:
float param bailout
	default = 4.0
endparam
}
