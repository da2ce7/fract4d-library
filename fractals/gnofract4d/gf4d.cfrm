comment {

Standard Gnofract4D coloring algorithms

}

default (OUTSIDE){
; the default is just to use the iteration count
final:
#index = #numiter / 256.0
}

basins {
final:
#index = (#fate * 1.0/@nbasins)
if @mode == "basin + iterations"
	#index = #index + (#numiter / 256.0) % @nbasins
elseif @mode == "basin + potential"
        float ed = @bailout/(|z| + 1.0e-9) 
	#index = #index + ((#numiter + ed)/ 256.0) % @nbasins
endif	
default:
int param nbasins
	default = 3
endparam
int param mode
	enum = "basin" "basin + iterations" "basin + potential"
	default = "basin + iterations"
endparam
float param bailout
	default = 4.0
endparam
}

zero (BOTH) {
final:
#solid = true
}

continuous_potential {
final:
float ed = @bailout/(|z| + 1.0e-9) 
#index = (#numiter + ed) / 256.0
default:
float param bailout
	default = 4.0
endparam
}

external_angle {
final:
float angle = atan2(z)
if angle < 0.0 
	angle = 2.0 * #pi + angle
endif
#index = angle / (2.0 * #pi)
}

biomorph {
final:
if |real(z)| < @zlimit || |imag(z)| < @zlimit
	#solid = true
else
	float ed = @bailout/(|z| + 1.0e-9) 
	#index = (#numiter + ed) / 256.0
endif
default:
float param zlimit
	default = 2.0
endparam	
float param bailout
	default = 4.0
endparam
}

decomposition {
final:
float quadrant = 0.0;
if(real(z) < 0.0) 
	quadrant = quadrant + 0.25
endif
if(imag(z) < 0.0) 
	quadrant = quadrant + 0.5
endif
#index = quadrant
}

ejection_distance {
final:
float ed = @bailout/(|z| + 1.0e-9) 
#index = ed
default:
float param bailout
	default = 4.0
endparam
}

rgb {
; for backwards compatibility with 1.x versions of Gnofract 4D.
; also rather cool looking
init:
	color ccol = @col * 10.0
	ccol = rgb(red(@col) + 1.0, green(@col) + 1.0, blue(@col) + 1.0)
final:
	float dist = #numiter / 256.0
	ccol = ccol * dist
	#color = rgb(red(ccol) % 256, green(ccol) % 256, blue(ccol) % 256)
default:
color param col
	default = rgb(1.0,0.0,0.0) 
endparam
}

rgb_parts {
; direct coloring algorithm which sets hsl separately
;
final:
	; hue = angle
	float angle = atan2(z)
	if angle < 0.0 
		angle = 2.0 * #pi + angle
	endif
	; convert to 0..6	
	float h = angle * 6.0 / (2.0 * #pi)
	
	; saturation =ejection distance
	float s = @bailout/(|z| + 1.0e-9) 

	; luminosity = #numiter
	float l = ((#numiter / #maxiter) - 1.0)*2.0 

	#color = hsl(h,s,l)
default:
float param bailout
	default = 4.0
endparam
}

Angles {
; delta total, total, min, delta min, max, delta max, avg, delta avg
; iter @ min, iter @ max, iter @ delta min, iter @ delta max
init:
float angle = 0.0
complex lastz = (0,0)
float temp_angle
int itermin = 0
int itermax = 0
if @angle_type == "delta min" || @angle_type == "min" || @angle_type == "iter @ min"
    angle = #pi
endif
loop:
if @angle_type == "delta total"
    angle = angle + abs(atan2(z-lastz))
elseif @angle_type == "delta max" 
    temp_angle = abs(atan2(z-lastz))
    if temp_angle > angle
	angle = temp_angle
    endif
elseif @angle_type == "delta min"
    temp_angle = abs(atan2(z-lastz))
    if temp_angle < angle
	angle = temp_angle
    endif
elseif @angle_type == "min" || @angle_type == "iter @ min"
    temp_angle = abs(atan2(z))
    if temp_angle < angle
	angle = temp_angle
	itermin = #numiter
    endif
elseif @angle_type == "max" || @angle_type == "iter @ max"
    temp_angle = abs(atan2(z))
    if temp_angle > angle
	angle = temp_angle
	itermax = #numiter
    endif
elseif @angle_type == "total"
    angle = angle + abs(atan2(z))
endif
lastz = z
final: 
if @angle_type == "iter @ min" 
    #index = itermin/256.0
elseif @angle_type == "iter @ max"
    #index = itermax/256.0
else 
    #index = angle/#pi
endif
default:
param angle_type
	default = 0
	enum = "delta total" "delta max" "delta min" "min" "max" "total" "iter @ min" "iter @ max"
endparam
}  
